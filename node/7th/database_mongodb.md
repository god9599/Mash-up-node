# 몽고디비

몽고디비의 특징 중 하나는 JS 문법을 사용한다는 것이다. 노드도 JS를 사용하므로 데이터베이스마저 몽고디비를 사용한다면 JS만 사용하여 웹 어플리케이션을 만들 수 있다. 하지만 몽고디비는 RDBMS가 아니라 NoSQL이므로 특징을 잘 알아야 한다.



## NoSQL vs SQL

> 이 글에서 설명하는 NoSQL의 특징은 몽고디비의 특징이므로, 다른 NoSQL 데이터베이스와는 차이가 있을 수 있다.

| SQL(MySQL)               | NoSQL(몽고디비)              |
| ------------------------ | ---------------------------- |
| 규칙에 맞는 데이터 입력  | 자유로운 데이터 입력         |
| 테이블 간 JOIN 지원      | 컬렉션 간 JOIN 미지원        |
| 안정성, 일관성           | 확장성, 가용성               |
| 용어(테이블, 로우, 컬럼) | 용어(컬렉션, 다큐먼트, 필드) |

* NoSQL에는 고정된 테이블이 없다. 테이블에 상응하는 컬렉션이라는 개념이 있지만, 컬럼을 따로 정의하지는 않는다.
* 몽고디비에는 JOIN을 흉내 낼 수는 있지만, 하나의 쿼리로 여러 테이블을 합치는 작업이 항상 가능하지는 않는다. 동시에 쿼리를 수행하는 경우 쿼리가 섞여 예상치 못한 결과를 낼 가능성이 있다는 것이 단점이다.
* 이러한 단점에도, 데이터를 빠르게 넣을 수 있고 쉽게 여러 서버에 데이터를 분산할 수 있다는 확장성과 가용성 때문에 사용한다.
* MySQL의 테이블, 로우, 컬럼을 몽고디비에서는 각각 컬렉션, 다큐먼트, 필드라고 한다.
* 어플리케이션을 만들 떄 꼭 한가지 데이터베이스만 사용하는 것은 아니다. 서로 다른 특징을 가지므로 알맞은 곳에 사용하면 된다.



## CRUD 



#### Create

* 컬렉션에 컬럼을 정의하지 않아도 되므로 컬렉션에는 아무 데이터나 넣을 수 있다. 
  * 이러한 자유로움이 몽고디비의 장점.
  * 단, 무엇이 들어올지 모른다는 단점도 있다.

* 몽고 디비의 자료형은  MySQL과 조금 다르다. 기본적으로 몽고디비는 자바스크립트 문법을 사용하므로 자바스크립트 자료형을 따른다. 추가로 몇 가지 자료형이 더 있다.
  * Date나 정규 표현식 같은 자바스크립트 객체를 자료형으로 사용할 수 있고, ObjectId, Long, Timestamp 등의 추가적인 자료형이 있다.
* db.컬렉션명.save(다큐먼트)로 생성한다.
  * ex) db.users.save({name:'joo', age:24, married:false, comment:'하이여'});
* 몽고디비 콤파스를 이용할 시  GUI 환경에서 편하게 생성할 수 있다.



#### Read

* db.컬렉션명.find({});   이런식으로 입력하면 생성한 다큐먼트들을 조회할 수 있다.

  * find({})는 컬렉션 내의 모든 다큐먼드를 조회하라는 뜻.

* 특정 필드만 조회하고 싶다면 다음과 같이 하자.

  * ex) db.users.find({}, {_id:0, name:1, married:1});
    * find  메서들의 두 번째 인수로 조회할 필드를 넣었다. 1또는  true로 표시한 필드만 가져온다.
    * _id는 기본적으로 가져오므로 0또는 false를 입력해서 가져오지 않도록 한 것이다.

* 조회 시 조건을 주려면 첫 번째 인수 객체에 기입하면 된다. 나이가 30초과 결혼한 다큐먼트의 이름과 나이를 조회해보자.

  ```javascript
  db.users.find({age:{$gt : 30}, married:true}, {_id:0, name:1, age:1});
  ```

  * $gt는 시퀄라이즈 쿼리와 비슷한데 초과라는 뜻을 가진다. 
    * or연산은 $or를 사용한다.
    * 아래 예시에서 $or에 주어진 배열 안의 조건들을 하나라도 만족하는 다큐먼트를 모두 찾는다.

  ```javascript
  db.users.find({$or:[{age:{$gt:30}}, {married:false}]}, {_id:0, name:1, age:1});
  ```

  * 정렬도 sort 메서드를 사용하면 된다. 나이가 많은 순서대로 정렬해보자.
    * -1은 내림차순, 1은 오름차순이다.

  ```javascript
  db.users.find({}, {_id:0, name:1, age:1}).sort({age:-1})
  ```

  

* 조회할 다큐먼트 개수를 설정할 수도 있다. limit 메서드를 사용한다.

  ```javascript
  db.users.find({}, {_id:0, name:1, age:1}).sort({age:-1}).limit(1)
  ```

* 다큐먼트 개수를 설정하면서 몇 개를 건너뛸 지 설정할 수 있다.  skip 메서드를 사용한다.

  ```javascript
  db.users.find({}, {_id:0, name:1, age:1}).sort({age:-1}).limit(1).skip(1)
  ```

* compass 에서는 filter를 주면 된다.



#### Update

```javascript
 db.users.update({name: 'kim'}, {$set: { age: 66}})
 
 // WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
```

* 첫 번째 객체는 수정할 다큐먼트를 지정하는 객체고, 두 번째 객체는 수정할 내용을 입력하는 객체
* $set이라는 연산자가 사용되었는데, 이 연산자는 어떤 필드를 수정할 지 정하는 연산자이다. 만약, 이 연산자를 사용하지 않고 일반 객체를 넣는다면, 다큐먼트가 통쨰로 두 번째 인수로 주어진 객체로 수정된다.

> 따라서 일부 필드만 수정하고 싶을 때는 반드시 $set 연산자를 지정해야 한다.

수정에 성공했다면 첫 번째 객체에 해당하는 다큐먼트 수와 수정된 다큐먼트 수가 나온다.



#### Delete

```javascript
db.users.remove({name: 'kim'})

// WriteResult({ "nRemoved" : 1 })
```

* 삭제할 다큐먼트에 대한 정보가 담긴 객체를 첫 번째 인수로 제공하면 된다.
* 성공 시 삭제된 개수가 반환된다.
